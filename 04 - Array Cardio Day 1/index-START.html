<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Array Cardio üí™</title>
</head>
<body>
  <p><em>Psst: have a look at the JavaScript Console</em> üíÅ</p>
  <script>
    // Get your shorts on - this is an array workout!
    // ## Array Cardio Day 1

    // Some data we can work with

    const inventors = [
      { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 },
      { first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 },
      { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 },
      { first: 'Marie', last: 'Curie', year: 1867, passed: 1934 },
      { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 },
      { first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 },
      { first: 'Max', last: 'Planck', year: 1858, passed: 1947 },
      { first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 },
      { first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 },
      { first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 },
      { first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 },
      { first: 'Hanna', last: 'Hammarstr√∂m', year: 1829, passed: 1909 }
    ];

    const people = ['Beck, Glenn', 'Becker, Carl', 'Beckett, Samuel', 'Beddoes, Mick', 'Beecher, Henry', 'Beethoven, Ludwig', 'Begin, Menachem', 'Belloc, Hilaire', 'Bellow, Saul', 'Benchley, Robert', 'Benenson, Peter', 'Ben-Gurion, David', 'Benjamin, Walter', 'Benn, Tony', 'Bennington, Chester', 'Benson, Leana', 'Bent, Silas', 'Bentsen, Lloyd', 'Berger, Ric', 'Bergman, Ingmar', 'Berio, Luciano', 'Berle, Milton', 'Berlin, Irving', 'Berne, Eric', 'Bernhard, Sandra', 'Berra, Yogi', 'Berry, Halle', 'Berry, Wendell', 'Bethea, Erin', 'Bevan, Aneurin', 'Bevel, Ken', 'Biden, Joseph', 'Bierce, Ambrose', 'Biko, Steve', 'Billings, Josh', 'Biondo, Frank', 'Birrell, Augustine', 'Black, Elk', 'Blair, Robert', 'Blair, Tony', 'Blake, William'];

    // Array.prototype.filter()
    // 1. Filter the list of inventors for those who were born in the 1500's
    const fifteen = inventors.filter(inventor => (inventor.year >= 1500 && inventor.year < 1600))
    console.table(fifteen);

    // The first example above takes the array inventors, and applies the .filter method.  By default this loops through each of the items in the array, and in this case we are taking a single argument, inventor (although we could have chosen to name this something completely different, like person) and we are returning those inventors where the property 'year' is both greater than or equal to 1500 and less than 1600.
    // The way the filter method works is that you pass it a function, and it will apply that function to each item in the array. The argument is inventor and the long handed way would be to take an if statement and then return true if it was true. By returning true, this would effectively keep those items inside the return. The above shorthand notation is just delivering anything which meets the condition stated above.

    // Array.prototype.map()
    // 2. Give us an array of the inventors' first and last names
    const inventorsFullNames = inventors.map(inventor => inventor.first + " " + inventor.last);
    console.log(inventorsFullNames);

    // This .map method creates a new array with the results of calling a specific function on each element in the array.  So the long hand of the above would be as follows:
    // const inventorsFullNames2 = inventors.map(function(inventor) {
    //   return inventor.first + " " + inventor.last;
    // });
    // console.log(inventorsFullNames2);

    // Array.prototype.sort()
    // 3. Sort the inventors by birthdate, oldest to youngest
    const inventorsAge = inventors.sort(function(a,b) {
      if (a.year > b.year) {
        return 1;
      } else {
        return -1;
      }
    });

    console.table(inventorsAge);

    // The .sort method sorts the elements of an array into a certai position and returns the updated array. We are using a compare function above, which basically works by saying that if its less than 0, you sort a to a lower index than b, i.e. a comes first.  If it is greater than 0, you sort a to a higher index than b, i.e. b comes first. if it returns 0, you leave a and b alone with respect to each other - the 0 would be used if a and b were equal to each other, for example. It effectively does this on the array repeatedly until everything is in the right order.



    // Array.prototype.reduce()
    // 4. How many years did all the inventors live?
    const totalYears = inventors.reduce((total, inventor) => {
      return total + (inventor.passed - inventor.year);
    }, 0);

    console.log(totalYears);

    // The .reduce method is one of the harder ones to understand. It basically applies a function against an accumulator and each element in the array, from left to right, to reduce it to a single number. The 'total' above is the running total.  The '0' is basically the number we use for the first time, as otherwise this would be undefined and the total sum would be undefined plus the number.


    // 5. Sort the inventors by years lived
    const oldest = inventors.sort(function(a,b) {
      const lastGuy = a.passed - a.year;
      const nextGuy = b.passed - b.year;
      return lastGuy > nextGuy ? -1 : 1;
    });

    console.table(oldest);

    // This is another sort function, but instead of just a and b on their own, we use them to define additional variables.  The return in the last line is shortland to say that if lastGuy is greater than nextGuy then return -1 otherwise return 1.

    // 6. create a list of Boulevards in Paris that contain 'de' anywhere in the name
    // https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris
    // const category = document.querySelector('.mw-category');
    // const links = Array.from(category.querySelectorAll('a'));
    // const de = links
    //             .map(link => link.textContent)
    //             .filter(streetName => streetName.includes('de'));


    // The above example was done in the console of the wikipedia page, but we are basically taking each of the items which have a class of '.mw-category'. Within that, we take each of the arrays.  We then loop through the arrays, first using .map to deliver a new array which has the text content, and then filtering through that and running a function which takes the argument streetName, to return only those items whereby the streetName includes the word 'de'.  As before, streetName could be called anything else, thats just the argument name.



    // 7. sort Exercise
    // Sort the people alphabetically by last name
    const alphabet = people.sort(function(a,b) {
    const [aLast, aFirst] = a.split(', ');
    const [bLast, bFirst] = b.split(', ');
    console.log(aLast, aFirst);
    if (aLast > bLast) {
      return 1
    } else {
      return -1
    }
    });
;
    console.log(alphabet);

    //The example above takes the people array, which this time does not consist of objects and sorts it.  Once again we need to define new variables, and the short hand for this is to take const [aLast, aFirst] and then split it into two different variables using the .split method. So this way we can sort based on just one of the variables, i.e. the last name.


    // 8. Reduce Exercise
    // Sum up the instances of each of these
    const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];

    const total = data.reduce(function(obj, item) {
      if (!obj[item]) {
        obj[item] = 0;
      }
      obj[item]++;
      return obj;
    }, {});

    console.log(total);

    // The example above once again takes the reduce method.  So we are taking each of the items in the array, using an accumulator, which we are calling object, and taking a second argument, which is the value.  So if we were to console log item, it knows that it is the independent value of each item in the array. So the obj[item] is the accunulator of each type of item.  Need some more practice on this function.

  </script>
</body>
</html>
